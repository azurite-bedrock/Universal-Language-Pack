name: Build

on:
    schedule:
        - cron: '0 0 * * 0'
    workflow_dispatch:

permissions:
    contents: write

jobs:
    bump-version:
        runs-on: ubuntu-latest
        outputs:
            tag-to-release: ${{ steps.determine_tag.outputs.tag_to_release }}
        steps:
            - uses: actions/checkout@v3
              with:
                  fetch-depth: 0
            - name: Get latest semver tag
              id: get_tag
              run: |
                  LATEST_TAG=$(git tag | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -t. -k1,1n -k2,2n -k3,3n | tail -n1)
                  if [ -z "$LATEST_TAG" ]; then
                    LATEST_TAG="0.0.0"
                  fi
                  echo "latest=$LATEST_TAG" >> $GITHUB_OUTPUT
            - name: Check if latest tag has a release
              id: check_release
              run: |
                  LATEST_TAG="${{ steps.get_tag.outputs.latest }}"
                  if gh release view "$LATEST_TAG" &>/dev/null; then
                    echo "has_release=true" >> $GITHUB_OUTPUT
                    echo "Tag $LATEST_TAG already has a release"
                  else
                    echo "has_release=false" >> $GITHUB_OUTPUT
                    echo "Tag $LATEST_TAG does not have a release"
                  fi
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            - name: Determine tag to release
              id: determine_tag
              run: |
                  LATEST_TAG="${{ steps.get_tag.outputs.latest }}"
                  HAS_RELEASE="${{ steps.check_release.outputs.has_release }}"

                  if [ "$HAS_RELEASE" = "true" ]; then
                    # Tag has a release, bump patch version
                    IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_TAG"
                    NEW_TAG="$MAJOR.$MINOR.$((PATCH+1))"
                    echo "tag_to_release=$NEW_TAG" >> $GITHUB_OUTPUT
                    echo "Will create new tag: $NEW_TAG"
                  else
                    # Tag doesn't have a release, use existing tag
                    echo "tag_to_release=$LATEST_TAG" >> $GITHUB_OUTPUT
                    echo "Will use existing tag: $LATEST_TAG"
                  fi
            - name: Create and push new tag (if needed)
              run: |
                  LATEST_TAG="${{ steps.get_tag.outputs.latest }}"
                  TAG_TO_RELEASE="${{ steps.determine_tag.outputs.tag_to_release }}"

                  if [ "$TAG_TO_RELEASE" != "$LATEST_TAG" ]; then
                    echo "Creating new tag: $TAG_TO_RELEASE"
                    git config user.name "github-actions[bot]"
                    git config user.email "github-actions[bot]@users.noreply.github.com"
                    git tag "$TAG_TO_RELEASE"
                    git push origin "$TAG_TO_RELEASE"
                  else
                    echo "Using existing tag: $TAG_TO_RELEASE"
                  fi

    build-and-release:
        needs: bump-version
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v3
              with:
                  ref: ${{ needs.bump-version.outputs.tag-to-release }}
            - name: Install Rust
              uses: dtolnay/rust-toolchain@stable
            - name: Install Deno
              uses: denoland/setup-deno@v1
              with:
                  deno-version: v1.x
            - uses: Bedrock-OSS/regolith-action@v1.1.0
              with:
                  profile: pack
            - uses: softprops/action-gh-release@v1
              with:
                  name: 'v${{ needs.bump-version.outputs.tag-to-release }}'
                  tag_name: ${{ needs.bump-version.outputs.tag-to-release }}
                  files: '*.mcpack'
                  fail_on_unmatched_files: true
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            # More detailed embed with download link
            - name: Send Discord notification
              if: success()
              run: |
                VERSION="${{ needs.bump-version.outputs.tag-to-release }}"
                REPO_URL="${{ github.server_url }}/${{ github.repository }}"
                RELEASE_URL="$REPO_URL/releases/tag/$VERSION"
                DOWNLOAD_URL="$REPO_URL/releases/download/$VERSION"
                
                # Get the .mcpack filename
                MCPACK_FILE=$(ls *.mcpack | head -n 1)
                
                curl -H "Content-Type: application/json" \
                    -d '{
                    "content": "",
                    "embeds": [{
                        "title": "ðŸ“¦ New ULP Release: v'"$VERSION"'",
                        "description": "A new version of Universal Language Pack has been released!",
                        "url": "'"$RELEASE_URL"'",
                        "color": 3066993,
                        "thumbnail": {
                        "url": "https://github.com/azurite-bedrock/Universal-Language-Pack/blob/main/packs/RP/pack_icon.png?raw=true"
                        },
                        "fields": [
                        {
                            "name": "Version",
                            "value": "`v'"$VERSION"'`",
                            "inline": true
                        },
                        {
                            "name": "Download",
                            "value": "['"$MCPACK_FILE"']('"$DOWNLOAD_URL/$MCPACK_FILE"')",
                            "inline": true
                        }
                        ],
                        "timestamp": "'"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)"'",
                        "footer": {
                        "text": "Automated Release",
                        "icon_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
                        }
                    }]
                    }' \
                    ${{ secrets.DISCORD_WEBHOOK_URL }}
              env:
                DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
